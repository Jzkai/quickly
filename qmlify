#! /usr/bin/env python3
import sys, re, os, os.path
import subprocess
from shutil import copy
import argparse

define = r'\nObject.defineProperty\(exports, "__esModule", \{\n\s*value: true\n\s*\}\);\n'
export_import = r'Object.defineProperty\(exports, \'(.+)\', \{\n\s*enumerable: true,\n\s*get: function get\(\) \{\n\s*return (.*).\1;\n\s*\}\n\s*\}\);'
require_as = r'\nvar (.+) = require\([\'\"](.+)[\'\"]\);\n'
require = r'\nrequire\(\'(.+)\'\);\n'
export = r'var (.+) = exports.\1 ='
require_default = 'function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }'
new_require_default = 'function _interopRequireDefault(obj) { return { default: obj.defaultExport }; }'

dependency_map = {}

class DependencyCycle(BaseException):
    def __init__(self, chain):
        super().__init__()
        self.chain = chain

def check_dependency(name, target, chain=None):
    if name not in dependency_map:
        return
    dependencies = dependency_map[name]

    if chain is None:
        chain = [target, name]

    for dep in dependencies:
        new_chain = chain + [dep]
        if dep == target:
            raise DependencyCycle(new_chain)
        else:
            check_dependency(dep, target, new_chain)

def register_dependency(filename, dependency):
    if filename not in dependency_map:
        dependency_map[filename] = []
    dependency_map[filename].append(dependency)

    check_dependency(dependency, filename)

def qmlify(filename, base_dir, build_dir, use_polyfills=True):
    dirname = os.path.dirname(filename)
    basename = os.path.basename(filename)
    rel_filename = os.path.relpath(filename, base_dir)
    out_filename = os.path.join(build_dir, rel_filename)
    out_dirname = os.path.dirname(out_filename)

    if os.path.exists(out_filename) and (os.path.getmtime(out_filename) >= os.path.getmtime(filename) and
                                         os.path.getmtime(out_filename) >= os.path.getmtime(__file__)):
        return

    print(' - ' + filename)

    if not os.path.exists(out_dirname):
        os.makedirs(out_dirname)

    if not filename.endswith('.js'):
        copy(filename, out_filename)
        return

    subprocess.run(['babel', filename, '-o', out_filename], check=True)

    with open(out_filename) as f:
        text = f.read()

    header = '.pragma library\n'
    post_header = ''

    if use_polyfills:
        header += '.import QuickFill 0.1 as QML_QuickFill\n'
        post_header += 'var _Polyfills = QML_QuickFill.Polyfills\n'
        post_header += 'var WeakMap = _Polyfills.WeakMap\n'
        post_header += 'var Map = _Polyfills.Map\n'
        post_header += 'var WeakSet = _Polyfills.WeakSet\n'
        post_header += 'var Set = _Polyfills.Set\n'
        post_header += 'var Symbol = _Polyfills.Symbol\n'
        post_header += 'var Reflect = _Polyfills.Reflect\n'
        post_header += 'var Promise = _Polyfills.Promise\n'
        post_header += 'var fetch = _Polyfills.fetch\n'
        post_header += 'var Request = _Polyfills.Request\n'
        post_header += 'var Response = _Polyfills.Response\n'
        post_header += 'var Headers = _Polyfills.Headers\n'

    # Convert npm-style requires to QML imports

    def qmlify_require(name, import_path):
        nonlocal header
        nonlocal post_header

        if import_path.startswith('./') or import_path.startswith('../'):
            if '.js' not in import_path:
                import_path += '.js'
            header += '.import "{}" as QML{}\n'.format(import_path, name)
            post_header += 'var {} = QML{}\n'.format(name, name)
        else:
            if re.fullmatch(r'.+\s+\d\.\d\/.+', import_path):
                import_path, module = filename.split('/')
                post_header += 'var {} = QML{}.{}\n'.format(name, name, module)
            else:
            	post_header += 'var {} = QML{}\n'.format(name, name)

            header += '.import {} as QML{}\n'.format(import_path, name)

        # Dependency graph stuff

        resolved_filename = os.path.abspath(filename)
        resolved_import_path = os.path.abspath(os.path.join(dirname, import_path))

        register_dependency(resolved_filename, resolved_import_path)

    for (name, import_path) in re.findall(require_as, text):
        qmlify_require(name, import_path)

    side_effect_index = 0

    for import_path in re.findall(require, text):
        name = '_side_effect' + str(side_effect_index)
        side_effect_index += 1

        qmlify_require(name, import_path)

    header += '\n' + post_header + '\n'

    text = text.replace(require_default, new_require_default)

    text = re.sub(require_as, '', text)
    text = re.sub(require, '', text)

    # Qmlify the esModule export
    text = re.sub(define, 'var __esModule = true;\n', text)

    text = re.sub(r'exports.default = (.+);\n', r'var defaultExport = \1;\n', text)

    # QML doesn't use the exports property; all top-levels are exported
    text = re.sub(export, r'var \1 =', text)
    text = re.sub(export_import, r'var \1 = \2.\1;', text)
    text = re.sub(r'\n(exports\.(.+) = )+undefined;\n', '\n', text)
    text = re.sub(r'exports\.(.+) = \1;\n', '', text)
    text = re.sub(r'exports\.(.+) = _\1;\n', r'var \1 = _\1;\n', text)

    text = header + text

    with open(out_filename, 'w') as file:
        file.write(text)


def qmlify_dir(path, build_dir, use_polyfills):
    for dirname, subdirs, files in os.walk(path):
        if os.path.exists(build_dir) and os.path.samefile(build_dir, dirname):
            continue
        for filename in files:
            qmlify(os.path.join(dirname, filename), path, build_dir, use_polyfills)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='QMLify ES6 source code.')
    parser.add_argument('source_files', metavar='source', type=str, nargs='+',
                       help='A ES6 source file to compile')
    parser.add_argument('build_dir', metavar='out', type=str,
                       help='The build directory to output built files to')
    parser.add_argument('--no-polyfills', dest='use_polyfills', action='store_const',
                       const=False, default=True,
                       help='Don\'t include the ES6 polyfills')

    args = parser.parse_args()

    build_dir = args.build_dir

    try:
        for filename in args.source_files:
            if os.path.isdir(filename):
                qmlify_dir(filename, build_dir, args.use_polyfills)
            else:
                qmlify(filename, os.path.dirname(filename), build_dir, args.use_polyfills)
    except DependencyCycle as cycle:
        print('Dependency cycle:\n - {}'.format('\n - '.join([os.path.relpath(path, os.getcwd())
                                                              for path in cycle.chain])))
        sys.exit(1)
