#! /usr/bin/env python3
import sys, re, os, os.path
import subprocess
from shutil import copy
import argparse

require_as = r'\nvar (.+) = require\([\'\"](.+)[\'\"]\);\n'
require = r'\nrequire\(\'(.+)\'\);\n'
export_import = r'Object.defineProperty\(exports, \'(.+)\', \{\n\s*enumerable: true,\n\s*get: function get\(\) \{\n\s*return (.*).\1;\n\s*\}\n\s*\}\);'
export_default_import = r'exports\.(.*) = (.*)\.default;\n'

dependency_map = {}
modules_map = {}

def find_module_files():
    qml_dir = subprocess.check_output(['qmake', '-query', 'QT_INSTALL_QML']).decode('utf-8').strip()
    modules = []
    for root, dirs, files in os.walk(qml_dir):
        for file in files:
            if file == 'package.yml':
                 modules.append(os.path.join(root, file))
    return modules

def load_yaml(fileName):
    from yaml import load
    try:
        from yaml import CLoader as Loader
    except ImportError:
        from yaml import Loader
    stream = open(fileName, "r")
    return load(stream, Loader=Loader)

def build_modules_map():
    for filename in find_module_files():
        yaml = load_yaml(filename)
        for name, qml_import in yaml.get('exports', {}).items():
            modules_map[name] = qml_import


class DependencyCycle(BaseException):
    def __init__(self, chain):
        super().__init__()
        self.chain = chain

def check_dependency(name, target, chain=None):
    if name not in dependency_map:
        return
    dependencies = dependency_map[name]

    if chain is None:
        chain = [target, name]

    for dep in dependencies:
        new_chain = chain + [dep]
        if dep == target:
            raise DependencyCycle(new_chain)
        else:
            check_dependency(dep, target, new_chain)

def register_dependency(filename, dependency):
    if filename not in dependency_map:
        dependency_map[filename] = []
    dependency_map[filename].append(dependency)

    check_dependency(dependency, filename)

def qmlify(filename, base_dir, build_dir, package_info, use_polyfills=True):
    dirname = os.path.dirname(filename)
    basename = os.path.basename(filename)
    rel_filename = os.path.relpath(filename, base_dir)
    out_filename = os.path.join(build_dir, rel_filename)
    out_dirname = os.path.dirname(out_filename)

    if os.path.exists(out_filename) and (os.path.getmtime(out_filename) >= os.path.getmtime(filename) and
                                         os.path.getmtime(out_filename) >= os.path.getmtime(__file__)):
        return

    print(' - ' + filename)

    if not os.path.exists(out_dirname):
        os.makedirs(out_dirname)

    if not filename.endswith('.js'):
        copy(filename, out_filename)
        return

    subprocess.run(['babel', filename, '-o', out_filename], check=True)

    with open(out_filename) as f:
        text = f.read()

    header = '.pragma library\n'
    post_header = 'var exports = {};\n'

    if use_polyfills:
        polyfills = [
            'WeakMap', 'Map', 'WeakSet', 'Set', 'Symbol', 'Reflect',
            'Promise', 'fetch', 'Request', 'Response', 'Headers'
        ]
        header += '.import QuickFill 0.1 as QML_QuickFill\n'
        post_header += 'var _Polyfills = QML_QuickFill.Polyfills.exports\n'
        for polyfill in polyfills:
            post_header += 'var {} = _Polyfills.{}\n'.format(polyfill, polyfill)

    # Convert npm-style requires to QML imports

    def qmlify_require(name, import_path):
        nonlocal header
        nonlocal post_header

        if import_path.startswith('./') or import_path.startswith('../'):
            if '.js' not in import_path:
                import_path += '.js'
            header += '.import "{}" as QML{}\n'.format(import_path, name)
            post_header += 'var {} = QML{}.exports;\n'.format(name, name)
        elif import_path in modules_map:
            module = modules_map[import_path]
            if ' ' in module:
                module, version = module.split(' ')
            if import_path in package_info.get('dependencies', {}):
                version = package_info.get('dependencies', {}).get(import_path)

            if version is None:
                print('No version specified and latest version not specified: ' + import_path)

            qml_module, qml_type = module.split('/')

            header += '.import {} {} as QML{}\n'.format(qml_module, version, name)
            post_header += 'var {name} = QML{name}.{qml_type}.exports ? QML{name}.{qml_type}.exports : QML{name}.{qml_type};\n'.format(name=name, qml_type=qml_type)
        else:
            raise Exception('Module not found: ' + import_path)


        # Dependency graph stuff

        resolved_filename = os.path.abspath(filename)
        resolved_import_path = os.path.abspath(os.path.join(dirname, import_path))

        register_dependency(resolved_filename, resolved_import_path)

    for (name, import_path) in re.findall(require_as, text):
        qmlify_require(name, import_path)

    side_effect_index = 0

    for import_path in re.findall(require, text):
        name = '_side_effect' + str(side_effect_index)
        side_effect_index += 1

        qmlify_require(name, import_path)

    header += '\n' + post_header + '\n'

    text = re.sub(require_as, '', text)
    text = re.sub(require, '', text)
    text = re.sub(export_import, r'var \1 = exports.\1 = \2.\1;', text)
    text = re.sub(export_default_import, r'var \1 = exports.\1 = \2.default;', text)
    export_default_import

    text = header + text

    with open(out_filename, 'w') as file:
        file.write(text)


def qmlify_dir(path, build_dir, package_info, use_polyfills=True):
    for dirname, subdirs, files in os.walk(path):
        if os.path.exists(build_dir) and os.path.samefile(build_dir, dirname):
            continue
        for filename in files:
            qmlify(os.path.join(dirname, filename), path, build_dir, package_info, use_polyfills)

build_modules_map()

class ModulesAction(argparse.Action):

    def __init__(self,
                 option_strings,
                 dest=argparse.SUPPRESS,
                 default=argparse.SUPPRESS,
                 help=None):
        super().__init__(
            option_strings=option_strings,
            dest=dest,
            default=default,
            nargs=0,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        print('{:25} {}'.format('ES6 Module Alias', 'Actual QML import'))
        print('-' * 70)
        for name, qml_module in modules_map.items():
            print('{:25} {}'.format(name, qml_module))
        parser.exit()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='QMLify ES6 source code.')
    parser.add_argument('source_files', metavar='source', type=str, nargs='+',
                       help='A ES6 source file to compile')
    parser.add_argument('build_dir', metavar='out', type=str,
                       help='The build directory to output built files to')
    parser.add_argument('--no-polyfills', dest='use_polyfills', action='store_false',
                       help='Don\'t include the ES6 polyfills')
    parser.add_argument('--modules', dest='show_modules', action=ModulesAction,
                        help='Show a list of QML modules mapped to ES6 module names')

    args = parser.parse_args()

    build_dir = args.build_dir

    if os.path.exists('package.yml'):
        package_info = load_yaml('package.yml')
    else:
        package_info = {}

    try:
        for filename in args.source_files:
            if os.path.isdir(filename):
                qmlify_dir(filename, build_dir, package_info, args.use_polyfills)
            else:
                qmlify(filename, os.path.dirname(filename), build_dir, package_info, args.use_polyfills)
    except DependencyCycle as cycle:
        print('Dependency cycle:\n - {}'.format('\n - '.join([os.path.relpath(path, os.getcwd())
                                                              for path in cycle.chain])))
        sys.exit(1)
